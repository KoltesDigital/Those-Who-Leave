#include <Camera>
#include "shader.glsl"

// maths
const float TAU = 6.28;

float hash,
	stepIndex;

// begin

// koltes & ponk
// using lines of code of IQ, Mercury, LJ, Duke

struct _M // Material
{
	float d, // distance
		m; // min distance
	vec3 c; // color
};

vec3 hsv(float h, float s, float v) {
    vec3 k=vec3(3.,2.,1.)/3.;
    vec3 p=abs(fract(h+k)*6.-3.);
    return v*mix(k.xxx,clamp(p-k.xxx,0.,1.), s);
}

// timing functions
float sequence (float start, float end) {
	return clamp((Beat-start)/(end-start), 0., 1.);
}
float sequenceSin (float start, float end) {
	return sin(sequence(start,end)*TAU/4.);
}

// transformation functions
mat2 rot (float a) {
	float c=cos(a), s=sin(a);
	return mat2(c,-s,s,c);
}

// noise functions

float hash1( float n ) {
	return fract(sin(n)*43758.5453);
}

float hash2(vec2 co) {
	return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);
}

float noiseIQ( vec3 x ) {
	vec3 p = floor(x);
	vec3 f = fract(x);
	f       = f*f*(3.0-2.0*f);
	float n = p.x + p.y*57.0 + 113.0*p.z;
	return mix(mix(mix( hash1(n+0.0), hash1(n+1.0),f.x),
	mix( hash1(n+57.0), hash1(n+58.0),f.x),f.y),
	mix(mix( hash1(n+113.0), hash1(n+114.0),f.x),
	mix( hash1(n+170.0), hash1(n+171.0),f.x),f.y),f.z);
}

float fbm (vec3 p, float s) {
	float value = 0.0;
	float amplitude = 1.;
	for (int i = 0; i < Octaves; ++i) {
		value += amplitude * noiseIQ(p);
		p *= 2.;
		p.yx *= rot(Beat*s*.5);
		p.yz *= rot(Beat*s*.3);
		p.xz *= rot(Beat*s*.6);
		amplitude *= .5;
	}
	return value;
}

void amod(inout vec2 p, float count) {
	float index = floor(mod(atan(p.y,p.x) / TAU * count + .5, count));
	hash = hash1(index);
	p *= rot(- index / count * TAU);
}

// volume distance sdf functions
float sdCone(vec3 p, vec2 c) { return dot(c, vec2(length(p.xy), p.z)); }
float sdSphere (vec3 p, float r) { return length(p)-r; }
float sdCylinder (vec3 p, float r, float h) { return max(abs(p.y)-h,length(p.xz)-r); }
float sdCylinderBox (vec3 p, float r, float h) {
	vec2 d = abs(p.xz) - r;
	return max(abs(p.y)-h, min(max(d.x,d.y),0.0) + length(max(d,0.0))); }
float sdPlane (float p, float r) { return abs(p)-r; }
float sdBox (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }
float sdIso (vec3 p, float r) { return dot(p, normalize(sign(p)))-r; }
float sdTorus( vec3 p, vec2 s ) {
  vec2 q = vec2(length(p.xz)-s.x,p.y);
  return length(q)-s.y;
}

// volume operation sdf functions
float smin (float a, float b, float r) {
	float h = clamp(.5+.5*(b-a)/r,0.,1.);
	return mix(b,a,h)-r*h*(1.-h);
}
float smax (float a, float b, float r) {
	float h = clamp(.5+.5*(b-a)/r,0.,1.);
	return mix(a,b,h)+r*h*(1.-h);
}
_M smin (_M a, _M b, float r) {
	float h = clamp(.5+.5*(b.d-a.d)/r,0.,1.);
	return _M(
		mix(b.d,a.d,h)-r*h*(1.-h),
		mix(b.m,a.m,h),
		mix(b.c,a.c,h)
	);
}
_M smax (_M a, _M b, float r) {
	float h = clamp(.5+.5*(b.d-a.d)/r,0.,1.);
	return _M(
		mix(a.d,b.d,h)+r*h*(1.-h),
		mix(a.m,b.m,h),
		mix(a.c,b.c,h)
	);
}
// displacement animation

float currentHeight () {
	return min(StemMaxHeight, StemGrowFactor * (Beat - StemStart));
}

vec3 stemDisplacement (vec3 p) {
	return vec3(cos(p.y),0.,sin(p.y))*.5;
}

float fadeHeight (vec3 p) {
	return sin(TAU/2.*clamp(p.y/StemMaxHeight,0.,1.));
}

float fadeCurrentHeight (vec3 p) {
	return sin(TAU/4.*(1.-clamp(p.y/currentHeight(),0.,1.)));
}

_M sdGround (vec3 p) {
	float radius = 5.;
	float rootDown = .5 * pow(length(p.xz)/radius, 2.);
	float noisy = fbm(p*2., 0.);
	return smax(
		_M(sdSphere(p, radius - noisy*.2), .001, GroundBottomColor),
		_M(p.y + rootDown * (1. + noisy), .001, mix(GroundTopColor0, GroundTopColor1, stepIndex/Steps)),
		.02);
}

_M sdSeed (vec3 p) {
	//p.y += mix(-4., 0., sequenceSin(SeedStart, SeedEnd+.1));
	//p.y += mix(0., 0.01, sequence(SeedEnd+.1, SeedEnd+.3));
	p.z += sin(p.x*25.+sin(p.z*20.))*sin(p.y*10.)*.02;
	p.xy *= rot(TAU/8.);
	p.xz *= rot(TAU/8.);
	p.xy /= .6;
	float radius = .5;
	vec3 q = p;
	q.xy *= rot(Beat);
	q.yz *= rot(Beat);
	return _M(mix(sdIso(p, radius), sdSphere(p, radius), .6), .01, hsv(noiseIQ(q + Beat / 4.), 1., 1.));
}


_M sdRoots (vec3 p) {
	float count = 12.;
	float subCount = 3.;

	amod(p.xz, count);
	float range = 3.;
	float d = length(p.xz);
	float len = 6. * sequence(RootStart+range*hash, RootEnd+range*hash);
	float fade = 1. - min(1., exp(RootFadeDamping * (d - len)));
	float rootDown = .8 * pow(d/5., 2.);
	float radius = (.1 + 0.02*sin(TAU * (Beat*.5 + d*.5 + hash))) * fade;
	p.xz *= rot(sin((3.+4.*hash)*(d+hash))*.1);
	p.y += RootAmplitude * cos(d * RootPulsation + hash) * min(1., exp(RootDamping * -d))
			+ rootDown + smoothstep(4.5, 8., d) * RootFall;

	p.x -= len;
	p.yz *= rot(p.y * RootSubHelixStep);
	amod(p.yz, subCount);
	p.y -= RootSubRadius;
	return _M(max(length(p.yz) - radius, max(d-len, -d))*.8, .001, mix(RootColor0, RootColor1, stepIndex/Steps));
}

_M sdMainStem (vec3 p) {
	float height = currentHeight();
	float fade = fadeHeight(p);
	p += stemDisplacement(p)*fade;
	p.xz *= rot(Beat-p.y*2.);
	float radius = mix(-1.,StemRadius, sequence(StemStart,StemStart+0.01));
	radius *= .4+.5*(1.-fadeCurrentHeight(p));
	float shape = max(sdCylinderBox(p, radius, height), -p.y);
	p.y -= height;
	float fadeSeed = mix(-1.,1.,sequence(StemStart+1.,StemStart+2.));
	shape = smin(shape, sdIso(p*.5,.1*fadeSeed), .1);
	return _M(shape, .001, mix(StemColor0, StemColor1, stepIndex/Steps));
}

float sdLeaf (vec3 p, float radius, float ratio) {

	p.y += p.x*(p.x/radius-3.)*.2;
	p.xy *= rot(.1 * sin(Beat * TAU / 4.));

	vec3 pStem = p;

	p.y -= sin(abs(2.*p.z/radius))*radius*.2;
	p.x += ( sin(abs(p.z/radius))*.5 - ratio * 2.) * radius;

	//float noise2 = fbm(p.xzz*4., .6);
	//float noisy = (noise2*2.-1.)*.5;
	//noisy += noise2*final * noise2*end;
	//p.y += noisy;

	float leaf = sdCylinder(p, ratio*radius, .05 * radius);

	// stem
	// cylinder stem shape
	float stem = sdCylinder(pStem.yxz, .1 * ratio * radius - .05 * pStem.x, 2.*radius);
	// crop
	stem = max(stem, -pStem.x);

	return smin(leaf, stem, .01);
}

_M sdLeafs(vec3 p) {
	float LeafInterval = 8. * StemGrowFactor;

	vec3 pOrig = p;

	float radius = 1.5,
		ratio = 1. - min(1., exp(-.2 * (Beat - StemStart - 8. * 9.)));

	float fade = fadeHeight(p);
	p += stemDisplacement(p)*fade;

	p.y -= 9. * LeafInterval;
	amod(p.xz, 4.);
	float shape = sdLeaf(p, radius, ratio);

	for (float index = 1.; index < 9.; ++index) {
		float fade = fadeHeight(pOrig);
		p = pOrig + stemDisplacement(pOrig)*fade;

		p.y -= index * LeafInterval;

		radius = .5 + .05 * index;
		ratio = 1. - min(1., exp(-.2 * (Beat - StemStart - 8. * index)));

		p.xz *= rot(3. - index * LeafInterval);
		shape = min(shape, sdLeaf(p, radius, ratio));
	}

	return _M(max(shape, -pOrig.y), .001, mix(StemColor0, StemColor1, stepIndex/Steps));
}

_M sdFlower (vec3 p0) {
	//p0 += normalize(p0)*hash2(p0.xz)*sequence(EndStart-.9, EndEnd)*30.;
	float noise2 = fbm(p0*2., .0);
	//p0.y += 3. * noise2 * sequence(FinalEnd, EndEnd-1.)*(length(p0.xz)+1.);
	p0.y -= currentHeight();
	vec3 p = p0;
	float count = 3.;
	float repeat = 5.;
	float bloom = mix(-1.,1., sequenceSin(FlowerStart, FlowerEnd));
	float radius = 1.*bloom;
	_M m;
	m.d = 1e5;
	for (float i = 0.; i < count; ++i) {
		p = p0;
		//p.y += -camHeight+1.;
		p.y -= i*.15;
		p.xz *= rot((Beat / 16. + i/count) * TAU);
		amod(p.xz, repeat);
		p.z *= 2.;
		p.xy *= rot(-TAU/6. +p.x*.2+.1*sin((Beat + i) * TAU / 4.));
		p.x -= 1.3*bloom;
		m = smin(m,
			_M(sdCylinder(p, radius, .01), .001,
				mix(vec3(1), hsv(hash - hash1(i) + Beat / 16., 1., 1.), stepIndex/Steps)), 0.2);
	}
	p = p0;
	p.xz *= rot(sin(p.y*5.+Beat)*.5);
	amod(p.xz, 8.);
	float height = 2.*bloom;
	p.x -= .2+.1*sin((p.y-StemMaxHeight-Beat/4.)*TAU);
	//p.x -= .8*(sin(-p.y)*.5+.5);
	//p.y += -camHeight+1.-height;
	m = smin(m, _M(max(sdCylinder(p, .02, height), -p0.y), .001, hsv(hash + Beat / 16., .6, 1.)), .1);
	m = smin(m, _M(sdSphere(p-vec3(0,height,0), .1*bloom), .001, vec3(1)), .1);
	return m;
}

_M sdCloud (vec3 p) {
	p.y -= 40.-20.*sin(TAU/8.*clamp(length(p.xz)/200.,0.,1.));
	float shape = abs(p.y+5.*fbm(p*.2, .05))-5.*(.2+.5*sin(p.x*.07))*(.2+.5*sin(p.z*.1+Beat));
	//shape = sdSphere(p, 1.+fbm(p, .1));
	shape = mix(1.,shape, clamp(length(p.xz),0.,1.));
	return _M(shape, 1., mix(CloudColor0, CloudColor1, stepIndex/Steps));
}

_M map (vec3 p) {
	_M scene = sdGround(p);
	scene = smin(scene, sdSeed(p), .1);
	scene = smin(scene, sdRoots(p), .1);
	scene = smin(scene, sdMainStem(p), .1);
	scene = smin(scene, sdLeafs(p), .1);
	scene = smin(scene, sdFlower(p), .1);
	scene = smin(scene, sdCloud(p), .1);
	return scene;
}

vec3 getNormal (vec3 p) {
	vec2 e = vec2(1e-3,0);
	return normalize(vec3(
		map(p+e.xyy).d - map(p-e.xyy).d,
		map(p+e.yxy).d - map(p-e.yxy).d,
		map(p+e.yyx).d - map(p-e.yyx).d
	));
}

void main() {
	vec2 uv = (gl_FragCoord.xy-.5*synth_Resolution.xy)/synth_Resolution.y;

	vec3 angles = mix(
		vec3(StartCameraAnglesX, StartCameraAnglesY, StartCameraAnglesZ),
		vec3(EndCameraAnglesX, EndCameraAnglesY, EndCameraAnglesZ),
		StartEndRatio
	),
	ray = normalize(vec3(uv,1)),
	pos = mix(
		vec3(StartCameraPositionX, StartCameraPositionY, StartCameraPositionZ),
		vec3(EndCameraPositionX, EndCameraPositionY, EndCameraPositionZ),
		StartEndRatio
	),
	color = ray * 0.;
	ray.xy *= rot(angles.z);
	ray.yz *= rot(angles.x);
	ray.xz *= rot(angles.y);

#ifdef SYNTHCLIPSE_ONLY
	if (SynthclipseCamera) {
		getCamera(pos, ray);
	}
#endif

	vec2 seed = uv + fract(Beat);
	for (stepIndex = 0.; stepIndex < Steps; ++stepIndex) {
		_M m = map(pos);
		if (abs(m.d) < m.m)
			color += m.c;
		pos += ray * max(m.m, abs(m.d)*(.8+.2*hash2(seed*stepIndex)));
	}
	color /= Steps;

	ray.xy *= rot(Beat*.02);
	ray.xz *= rot(.5);
	gl_FragColor = vec4(mix(
			mix(
				mix(SkyColor0, SkyColor1, noiseIQ(ray*5.)*noiseIQ(ray*.2))
			, StarColor, smoothstep(.94, 1., noiseIQ(ray*1e2))),
			color, step(1e-5, color))
		 * Exposure
		 * sequence(FadeInStart, FadeInEnd)
	 	 * sequence(FadeOutEnd, FadeOutStart)
	, 1.);
}

//! <preset file="shader.preset" />
